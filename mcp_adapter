/**
 * MCP Adapter (minimal)
 *
 * - GET /tools        -> returns MCP-style tool metadata + JSON schemas
 * - POST /call        -> executes a tool by proxying to existing local endpoints
 * - GET /components   -> stub for optional UI component hints
 *
 * Usage: require('./mcp_adapter')(app, { localBaseUrl: process.env.LOCAL_BASE_URL })
 */

const fetch = require('node-fetch');

module.exports = function attachMcpAdapter(app, opts = {}) {
  const PORT = process.env.PORT || 3000;
  const localBaseUrl = opts.localBaseUrl || process.env.LOCAL_BASE_URL || `http://localhost:${PORT}`;

  // Tool catalog — add more tool entries here following the same pattern
  const tools = [
    {
      id: "search_and_call",
      name: "Search Restaurants and Call",
      description: "Search for restaurants by cuisine/location and start automated reservation calls.",
      input_schema: {
        type: "object",
        required: ["cuisine", "location", "party_size", "date"],
        properties: {
          cuisine: { type: "string", description: "Cuisine type (e.g., italian)" },
          location: { type: "string", description: "Location or 'near me'" },
          party_size: { type: "integer", description: "Number of people" },
          date: { type: "string", pattern: "^\\d{4}-\\d{2}-\\d{2}$", description: "YYYY-MM-DD" },
          time: { type: "string", description: "HH:mm (required if intent is 'specific_time')" },
          intent: { type: "string", enum: ["specific_time", "any_time"], default: "specific_time" },
          max_calls: { type: "integer", description: "Maximum restaurants to call" }
        }
      },
      output_schema: {
        type: "object",
        properties: {
          ok: { type: "boolean" },
          message: { type: "string" },
          batchId: { type: "string" },
          mapUrl: { type: "string" },
          restaurants: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                international_phone_number: { type: "string" },
                place_id: { type: "string" },
                rating: { type: "number" }
              }
            }
          },
          query: { type: "object" }
        }
      },
      version: "0.1.0"
    }
  ];

  // GET /tools — return list of tools
  app.get('/tools', (_req, res) => {
    res.json({ ok: true, tools });
  });

  // GET /components — optional UI components/hints (stub)
  app.get('/components', (_req, res) => {
    res.json({ ok: true, components: [] });
  });

  // POST /call — execute a tool
  // Body: { tool_id: string, input: object }
  app.post('/call', async (req, res) => {
    try {
      const { tool_id, input } = req.body || {};
      if (!tool_id) return res.status(400).json({ ok: false, error: "Missing tool_id" });

      const tool = tools.find(t => t.id === tool_id);
      if (!tool) return res.status(404).json({ ok: false, error: "Tool not found" });

      // For now we only implement proxy to the local REST endpoint for search_and_call.
      if (tool_id === 'search_and_call') {
        const targetUrl = `${localBaseUrl}/restaurants/search_and_call`;
        const resp = await fetch(targetUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(input || {})
        });
        const data = await resp.json().catch(() => ({ ok: false, error: "Invalid JSON response" }));
        return res.status(resp.status).json({ ok: true, tool_id, output: data });
      }

      return res.status(501).json({ ok: false, error: "Tool execution not implemented" });

    } catch (err) {
      console.error("[MCP Adapter] /call error:", err);
      return res.status(500).json({ ok: false, error: "Internal adapter error" });
    }
  });

  console.log("✅ MCP adapter mounted: GET /tools  POST /call  GET /components");
  console.log(`✅ Adapter will proxy local calls to: ${localBaseUrl}`);
};
